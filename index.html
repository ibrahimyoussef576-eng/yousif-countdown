<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Countdown Until I Return</title>
<style>
:root{
  --bg1:#4facfe; --bg2:#00f2fe;
  --card: rgba(255,255,255,0.16);
  --text:#0f172a; --cardText:#ffffff;
  --accent:#ffeb3b; --shadow:0 10px 30px rgba(0,0,0,0.25);
}
.dark{
  --bg1:#0f172a; --bg2:#1e293b;
  --card: rgba(255,255,255,0.08);
  --text:#e5e7eb; --cardText:#e5e7eb; --accent:#ffd54f;
}
*{box-sizing:border-box}
html,body{height:100%}
body{ margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; color:var(--text); overflow-x:hidden; }
.bg-animated{ position:fixed; inset:0; z-index:-3; background: linear-gradient(135deg, var(--bg1), var(--bg2)); background-size: 200% 200%; animation: grad 18s ease-in-out infinite; }
@keyframes grad{ 0%{background-position:0% 0%} 50%{background-position:100% 100%} 100%{background-position:0% 0%} }
#particles{ position:fixed; inset:0; z-index:-2; pointer-events:none; }

header{ text-align:center; padding:34px 16px 6px; }
h1{ margin:0 0 10px; font-weight:900; font-size: clamp(28px, 4vw, 44px); text-shadow: 0 6px 18px rgba(0,0,0,.25); }
.controls{ display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:10px; }
button{
  border:none; color:var(--cardText); background: rgba(255,255,255,0.22);
  padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer;
  backdrop-filter:saturate(160%) blur(4px); box-shadow: var(--shadow);
  transition: transform .12s ease, background .2s ease;
}
.dark button{ background: rgba(255,255,255,0.14); }
button:hover{ transform: translateY(-1px) scale(1.02); background: rgba(255,255,255,0.30); }

.grid{ display:flex; justify-content:center; padding: 18px 16px 40px; }
.card{
  position:relative; width:min(560px, 94vw);
  padding:22px 22px 26px; border-radius:18px; background: var(--card);
  box-shadow: var(--shadow); overflow:hidden; backdrop-filter:saturate(160%) blur(8px);
}
.label{ font-size: clamp(16px, 2.2vw, 22px); font-weight:900; margin-bottom:12px; text-align:center; color:var(--cardText); }
.time{ font-variant-numeric: tabular-nums; font-weight:900; font-size: clamp(28px, 4vw, 40px); text-align:center; color: var(--accent); text-shadow: 0 0 12px rgba(0,0,0,.55); transition: transform .18s ease; }
.time.updated{ transform: scale(1.05); }

.progress-wrap{ margin:18px auto 6px; width:92%; }
.progress-track{ height:12px; border-radius:999px; background: rgba(255,255,255,.25); overflow:hidden; }
.progress-bar{ height:100%; width:0%; background: linear-gradient(90deg,#34d399,#06b6d4); transition: width .6s ease; }

.msg{ text-align:center; margin-top:12px; opacity:.95; font-weight:700; }

.mask{ position:absolute; inset:0; display:grid; place-items:center; text-align:center; background: #000; color:#fff; z-index:2; }
.mask .inner{ display:flex; flex-direction:column; align-items:center; gap:10px; }
.scratchWrap{ position:absolute; inset:0; z-index:3; display:none; touch-action: none; }
#scratchCanvas{ width:100%; height:100%; display:block; }

footer{ text-align:center; opacity:.85; margin:10px 0 10px; font-size:1rem; font-weight:700; }
#dailyQuote{ text-align:center; margin:0 12px 12px; font-style:italic; opacity:0.9; }

/* Leaderboard */
#leaderboard{ width:min(620px, 94vw); margin:6px auto 28px; background: var(--card); border-radius:14px; padding:12px 14px; box-shadow: var(--shadow); backdrop-filter:saturate(160%) blur(8px); }
#leaderboard h3{ margin:0 0 8px; text-align:center; }
#leaderboard ol{ margin: 0; padding-left: 22px; }
#leaderboard li{ margin: 6px 0; }
.lb-meta{ opacity:.8; font-size:.9em; }

#confetti, #emojiRain{ position:fixed; inset:0; pointer-events:none; z-index:10; }

/* Game modal */
.modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,0.7); z-index:20; }
.modalContent{ width:min(620px, 94vw); background: var(--card); color:var(--cardText); border-radius:18px; box-shadow: var(--shadow); padding:16px 16px 22px; position:relative; backdrop-filter:saturate(160%) blur(8px); }
.modalHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
.closeX{ background: rgba(255,255,255,0.22); border:none; border-radius:10px; padding:6px 10px; cursor:pointer; font-weight:800; }
#gameCanvas{ width:100%; height:420px; background: rgba(0,0,0,0.1); border-radius:14px; display:block; touch-action: none; }
.gameBar{ display:flex; justify-content:space-between; align-items:center; margin:10px 4px 4px; font-weight:800; }
.gameHint{ opacity:.9; font-size:.95em; margin-top:6px; text-align:center;}
.nameBtn{ margin-left:6px; }

/* DOUBLE MODE badge */
.doubleBadge{
  position:absolute; top:10px; left:50%; transform:translateX(-50%);
  background:#7c3aed; color:#fff; font-weight:900; padding:4px 10px; border-radius:999px;
  box-shadow: var(--shadow); opacity:0; transition: opacity .2s ease;
  pointer-events:none; z-index:30;
}
.doubleBadge.show{ opacity:1; }
</style>
</head>
<body>
<div class="bg-animated"></div>
<canvas id="particles"></canvas>
<canvas id="confetti"></canvas>
<canvas id="emojiRain"></canvas>

<header>
  <h1>‚è≥ Countdown Until I Return</h1>
  <div class="controls">
    <button id="revealBtn">üîç Reveal Timer</button>
    <button id="scratchBtn">ü™Ñ Scratch-to-Reveal</button>
    <button id="toggleFormatBtn">üîÅ Toggle Format</button>
    <button id="themeBtn">üåì Theme</button>
    <button id="gameBtn">üéÆ Mini Game</button>
  </div>
</header>

<section class="grid">
  <article class="card" id="card">
    <div class="label">Return date (Target: Sept 12)</div>

    <div class="progress-wrap">
      <div class="progress-track"><div class="progress-bar" id="progressBar"></div></div>
      <div style="text-align:center; margin-top:6px; font-weight:700;" id="progressText"></div>
    </div>

    <div id="countdown" class="time">--</div>
    <div class="msg" id="msg">I am almost back</div>

    <div class="mask" id="mask">
      <div class="inner">
        <div style="font-weight:800;font-size:1.1em">Hidden until reveal üòÑ</div>
        <div>Tap <strong>Reveal Timer</strong> or try <strong>Scratch-to-Reveal</strong>.</div>
      </div>
    </div>
    <div class="scratchWrap" id="scratchWrap">
      <canvas id="scratchCanvas"></canvas>
    </div>
  </article>
</section>

<footer>I‚Äôll be back soon! Meow Meow Meow</footer>
<div id="dailyQuote"></div>

<!-- Leaderboard -->
<div id="leaderboard">
  <h3>Leaderboard (Top 10)</h3>
  <ol id="lbList"></ol>
  <div class="lb-meta" id="lbMeta"></div>
</div>

<!-- Game modal -->
<div class="modal" id="gameModal" aria-hidden="true">
  <div class="modalContent">
    <div class="modalHeader">
      <strong>üéÆ Shape Catch ‚Äî 30s</strong>
      <div>
        <button class="closeX nameBtn" id="setNameBtn">Set Name</button>
        <button class="closeX" id="startGameBtn">Start</button>
        <button class="closeX" id="closeGameBtn">√ó</button>
      </div>
    </div>
    <div class="gameBar">
      <div>Score: <span id="score">0</span></div>
      <div>Time: <span id="time">30</span>s</div>
      <div>Best: <span id="best">0</span></div>
    </div>
    <div class="doubleBadge" id="doubleBadge">√ó2 MODE</div>
    <canvas id="gameCanvas"></canvas>
    <div class="gameHint">Move with ‚Üê/‚Üí or mouse. On phone: drag left/right.</div>
  </div>
</div>

<!-- ========= 1) Firebase + GLOBAL LEADERBOARD (MODULE) ========= -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-analytics.js";
  import {
    getFirestore, collection, addDoc, serverTimestamp,
    query, orderBy, limit, getDocs, where
  } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDAyKfDDVeZpidguVlhSzjXzXD0Ixv5DTo",
    authDomain: "countdown-87ab5.firebaseapp.com",
    projectId: "countdown-87ab5",
    storageBucket: "countdown-87ab5.firebasestorage.app",
    messagingSenderId: "587988485298",
    appId: "1:587988485298:web:3bda8da4969387afbab5ab",
    measurementId: "G-KGZ1E5LY52"
  };

  const app = initializeApp(firebaseConfig);
  getAnalytics(app);
  const db  = getFirestore(app);
  const scoresCol = collection(db, "scores");

  // Local name helpers
  const NAME_KEY = "shapeCatchPlayerName";
  function getName(){ return localStorage.getItem(NAME_KEY) || ""; }
  function setName(n){ localStorage.setItem(NAME_KEY, n); }

  // Escape helper
  function esc(s){ return (s||"").replace(/[&<>\"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;" }[m])); }

  // Get best score for a specific name
  async function fetchBestForName(name){
    const snap = await getDocs(query(scoresCol, where("name","==",name), limit(50)));
    let best = 0;
    snap.forEach(doc=>{
      const d = doc.data();
      if (typeof d.score === "number" && d.score > best) best = d.score;
    });
    return best;
  }

  // Render Top 10 UNIQUE names (best score per name)
  async function renderLB(){
    const list = document.getElementById("lbList");
    const meta = document.getElementById("lbMeta");
    if(!list) return;

    list.innerHTML = "<li>Loading‚Ä¶</li>";
    try{
      const qTop = query(scoresCol, orderBy("score","desc"), limit(200));
      const snap = await getDocs(qTop);

      const seen = new Set();
      const unique = [];
      snap.forEach(doc=>{
        const d = doc.data();
        const name = (d.name || "Anonymous").toString();
        const score = Number(d.score) || 0;
        const createdAt = d.createdAt?.toDate ? d.createdAt.toDate() : new Date();
        if (!seen.has(name)) {
          seen.add(name);
          unique.push({ name, score, createdAt });
        }
      });

      const top10 = unique.slice(0,10);

      list.innerHTML = "";
      if(top10.length === 0){
        list.innerHTML = "<li>No scores yet. Be the first! üéØ</li>";
      } else {
        top10.forEach((row, i)=>{
          const ts = `${row.createdAt.toLocaleDateString()} ${row.createdAt.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`;
          const li = document.createElement("li");
          li.innerHTML = `<strong>${i+1}.</strong> ${esc(row.name)} ‚Äî <strong>${row.score}</strong> <span class="lb-meta">(${ts})</span>`;
          list.appendChild(li);
        });
      }
      meta.textContent = "MANOFSTEEL sucks...";
    }catch(err){
      list.innerHTML = "<li>Could not load leaderboard. üòø</li>";
      meta.textContent = String(err);
      console.error(err);
    }
  }

  // Save score only if it beats this name's previous best
  async function addScore(name, score){
    try{
      const cleanName = (name || "Anonymous").toString().trim().slice(0,20);
      const safeScore = Math.max(0, Math.min(500, Number(score) || 0));

      const prevBest = await fetchBestForName(cleanName);
      if (safeScore <= prevBest) {
        await renderLB();
        return;
      }

      await addDoc(scoresCol, {
        name: cleanName,
        score: safeScore,
        createdAt: serverTimestamp()
      });

      await renderLB();
    }catch(err){
      console.error("Failed to submit score:", err);
      alert("Could not submit score right now. Try again later.");
    }
  }

  // expose to non-module script
  window.renderLB = renderLB;
  window.addScore = addScore;
  window.getName = getName;
  window.setName = setName;

  renderLB();
</script>

<!-- ========= 2) APP LOGIC (NON-MODULE) ========= -->
<script>
/* === Config === */
const TARGET_DATE = new Date("Sep 12, 2025 00:00:00").getTime();
const START_DATE  = new Date("Jun 15, 2025 00:00:00").getTime();
const REVEAL_THRESHOLD = 0.90;

/* === Countdown / Progress / Message === */
let compactFormat = false, finished = false;
const elTime = document.getElementById("countdown");
const elBar  = document.getElementById("progressBar");
const elProgText = document.getElementById("progressText");
const elMsg  = document.getElementById("msg");

function fmt(distance){
  const d = Math.floor(distance / (1000*60*60*24));
  const h = Math.floor((distance % (1000*60*60*24)) / (1000*60*60));
  const m = Math.floor((distance % (1000*60*60)) / (1000*60));
  const s = Math.floor((distance % (1000*60)) / 1000);
  return compactFormat ? `${d} days ‚Ä¢ ${h}h` : `${d}d ${h}h ${m}m ${s}s`;
}
function updateMessage(dist){
  const twoWeeks = 14 * 24 * 60 * 60 * 1000;
  if (dist > twoWeeks) elMsg.textContent = "Just a few weeks left";
  else if (dist > 0) {
    const days = Math.floor(dist / (1000*60*60*24));
    const weeks = Math.floor(days / 7);
    const remDays = days % 7;
    let msg = "Just ";
    if (weeks > 0) {
      msg += weeks + (weeks === 1 ? " week" : " weeks");
      if (remDays > 0) msg += " and " + remDays + (remDays === 1 ? " day" : " days");
    } else { msg += days + (days === 1 ? " day" : " days"); }
    elMsg.textContent = msg + " left";
  } else elMsg.textContent = "I am back! üéâ";
}
function tick(){
  const now = Date.now();
  const dist = TARGET_DATE - now;
  if(dist <= 0 && !finished){
    finished = true;
    elTime.textContent = "üéâ It's time!";
    celebrate();
  }
  if(dist > 0){
    elTime.textContent = fmt(dist);
    elTime.classList.add("updated");
    setTimeout(()=>elTime.classList.remove("updated"), 180);
  }
  updateMessage(dist);
  const total = TARGET_DATE - START_DATE;
  const done  = Math.max(0, Math.min(total, now - START_DATE));
  const pct   = Math.max(0, Math.min(100, (done/total)*100));
  elBar.style.width = pct.toFixed(1) + "%";
  elProgText.textContent = `Progress: ${pct.toFixed(1)}%`;
}
setInterval(tick, 1000); tick();
document.getElementById("toggleFormatBtn").onclick = ()=>{ compactFormat = !compactFormat; tick(); };
document.getElementById("themeBtn").onclick = ()=>{ document.body.classList.toggle("dark"); };

/* === Reveal / Scratch === */
const mask = document.getElementById("mask");
const scratchWrap = document.getElementById("scratchWrap");
const scratchCanvas = document.getElementById("scratchCanvas");
document.getElementById("revealBtn").onclick = ()=>{ mask.style.display="none"; scratchWrap.style.display="none"; };
document.getElementById("scratchBtn").onclick = ()=>{
  mask.style.display="none"; scratchWrap.style.display="block"; initScratch();
};
function initScratch(){
  const c = scratchCanvas, ctx = c.getContext("2d");
  const wrapRect = scratchWrap.getBoundingClientRect();
  const DPR = window.devicePixelRatio || 1;
  c.width = Math.max(1, Math.floor(wrapRect.width * DPR));
  c.height = Math.max(1, Math.floor(wrapRect.height * DPR));
  c.style.width = wrapRect.width + "px";
  c.style.height = wrapRect.height + "px";
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.globalCompositeOperation = "source-over"; ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, wrapRect.width, wrapRect.height);
  ctx.globalCompositeOperation = "destination-out";
  let scratching = false; const brush = 28;
  function pos(e){ const t = e.touches ? e.touches[0] : e; return { x: t.clientX - wrapRect.left, y: t.clientY - wrapRect.top }; }
  function draw(e){ if(!scratching) return; e.preventDefault(); const p = pos(e); ctx.beginPath(); ctx.arc(p.x,p.y,brush,0,Math.PI*2); ctx.fill(); }
  function start(e){ scratching = true; draw(e); } function end(){ scratching = false; }
  scratchWrap.addEventListener("mousedown", start);
  scratchWrap.addEventListener("mousemove", draw);
  window.addEventListener("mouseup", end);
  scratchWrap.addEventListener("touchstart", start, { passive:false });
  scratchWrap.addEventListener("touchmove",  draw,  { passive:false });
  scratchWrap.addEventListener("touchend",   end,   { passive:false });
  scratchWrap.addEventListener("touchcancel",end,   { passive:false });
  function clearedFraction(){
    const w=c.width,h=c.height,step=Math.max(4,Math.floor(Math.min(w,h)/180));
    let clear=0,total=0; const data=ctx.getImageData(0,0,w,h).data;
    for(let y=0;y<h;y+=step){ let row=(y*w)*4; for(let x=0;x<w;x+=step){ if(data[row+x*4+3]===0) clear++; total++; } }
    return total ? clear/total : 0;
  }
  const timer = setInterval(()=>{ if(clearedFraction()>REVEAL_THRESHOLD) scratchWrap.style.display="none"; },700);
  const obs=new MutationObserver(()=>{ if(scratchWrap.style.display==="none"){clearInterval(timer); obs.disconnect();} });
  obs.observe(scratchWrap,{attributes:true,attributeFilter:["style"]});
}

/* === Background particles === */
(function particles(){
  const canvas=document.getElementById("particles"),ctx=canvas.getContext("2d");
  let w,h; function resize(){ w=canvas.width=innerWidth; h=canvas.height=innerHeight; }
  resize(); addEventListener("resize", resize);
  const N=60,p=[]; for(let i=0;i<N;i++) p.push({x:Math.random()*w,y:Math.random()*h,r:1+Math.random()*3,vx:(Math.random()-0.5)*0.4,vy:(Math.random()-0.5)*0.4,a:0.18+Math.random()*0.25});
  (function step(){ ctx.clearRect(0,0,w,h); for(const s of p){ s.x+=s.vx; s.y+=s.vy; if(s.x<-10)s.x=w+10; if(s.x>w+10)s.x=-10; if(s.y<-10)s.y=h+10; if(s.y>h+10)s.y=-10; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fillStyle=`rgba(255,255,255,${s.a})`; ctx.fill(); } requestAnimationFrame(step); })();
})();

/* === Celebration === */
function celebrate(){ confettiBurst(1000,160); emojiRain("üéâ‚ú®üéä‚ù§Ô∏èüöó‚úàÔ∏è",2200); playDing(); }
function confettiBurst(duration=1200,count=120){
  const c=document.getElementById("confetti"),ctx=c.getContext("2d"); let w,h; function resize(){ w=c.width=innerWidth; h=c.height=innerHeight; } resize();
  const flakes=[]; for(let i=0;i<count;i++) flakes.push({x:Math.random()*w,y:-Math.random()*h*0.3,r:4+Math.random()*4,vx:(Math.random()-0.5)*3,vy:2+Math.random()*3,rot:Math.random()*Math.PI,vr:(Math.random()-0.5)*0.2});
  const start=performance.now(); (function frame(now){ const t=now-start; ctx.clearRect(0,0,w,h); flakes.forEach(f=>{ f.x+=f.vx; f.y+=f.vy; f.rot+=f.vr; ctx.save(); ctx.translate(f.x,f.y); ctx.rotate(f.rot); ctx.fillStyle=`hsl(${(f.x/w)*360},90%,55%)`; ctx.fillRect(-f.r,-f.r,f.r*2,f.r*2); ctx.restore(); }); if(t<duration) requestAnimationFrame(frame); else ctx.clearRect(0,0,w,h); })(performance.now());
}
function emojiRain(chars="üéâ‚ú®",duration=2000){
  const c=document.getElementById("emojiRain"),ctx=c.getContext("2d"); let w,h; function resize(){ w=c.width=innerWidth; h=c.height=innerHeight; } resize();
  const arr=chars.split(""),drops=Array.from({length:40},()=>({x:Math.random()*w,y:-Math.random()*h*0.2,vy:2+Math.random()*3,emoji:arr[Math.floor(Math.random()*arr.length)],size:24+Math.random()*22}));
  const start=performance.now(); (function frame(now){ const t=now-start; ctx.clearRect(0,0,w,h); drops.forEach(d=>{ d.y+=d.vy; ctx.font=`${d.size}px system-ui`; ctx.fillText(d.emoji,d.x,d.y); }); if(t<duration) requestAnimationFrame(frame); else ctx.clearRect(0,0,w,h); })(performance.now());
}
function playDing(){ try{ const a=new (window.AudioContext||window.webkitAudioContext)(); const o=a.createOscillator(),g=a.createGain(); o.type="sine"; o.frequency.setValueAtTime(880,a.currentTime); g.gain.setValueAtTime(0.001,a.currentTime); g.gain.exponentialRampToValueAtTime(0.3,a.currentTime+0.02); g.gain.exponentialRampToValueAtTime(0.0001,a.currentTime+0.8); o.connect(g).connect(a.destination); o.start(); o.stop(a.currentTime+0.8);}catch(e){} }

/* === Daily Quote === */
const quotesList = [
  "I can do all things through Christ who strengthens me. -Philippians 4:13",
  "For with God nothing will be impossible. -Luke 1:37",
  "The wait makes the return sweeter. ‚ù§Ô∏è",
  "Keep going ‚Äî you're doing amazing. üöÄ",
  "Almost there! üôå"
];
function showDailyQuote(){ const today=new Date().getDate(); const idx=today%quotesList.length; const el=document.getElementById("dailyQuote"); if(el) el.textContent=quotesList[idx]; }
if(document.readyState==="loading"){ document.addEventListener("DOMContentLoaded", showDailyQuote); } else { showDailyQuote(); }

/* === Mini Game: Shape Catch (Bombs + Tiny Fast √ó2 Mode) === */
const gameBtn=document.getElementById("gameBtn");
const gameModal=document.getElementById("gameModal");
const startGameBtn=document.getElementById("startGameBtn");
const closeGameBtn=document.getElementById("closeGameBtn");
const setNameBtn=document.getElementById("setNameBtn");
const gameCanvas=document.getElementById("gameCanvas");
const scoreEl=document.getElementById("score");
const timeEl=document.getElementById("time");
const bestEl=document.getElementById("best");
const doubleBadge=document.getElementById("doubleBadge");

let gCtx,gw,gh,rafId,running=false,tLeft=30,score=0,best=0,lastSpawn=0;
let catcher,drops=[];
let flashUntil=0; // red flash when bomb hit
let doubleUntil=0; // timestamp until double points active

best=+localStorage.getItem("shapeCatchBest")||0; bestEl.textContent=best;

function openGame(){ gameModal.style.display="flex"; resizeGame(); if(!window.getName || !window.getName() || window.getName().trim()===""){ askForName(); } }
function closeGame(){ gameModal.style.display="none"; stopGame(); }
gameBtn.onclick=openGame; closeGameBtn.onclick=closeGame; setNameBtn.onclick=askForName;

function askForName(){
  const current = window.getName ? window.getName() : "";
  const n = prompt("Enter your name for the leaderboard:", current || "");
  if(n !== null){
    const trimmed = (n || "").trim().slice(0,20);
    if(window.setName) window.setName(trimmed || "Anonymous");
    alert(`Name set to: ${window.getName()}`);
  }
}

function resizeGame(){
  const DPR=window.devicePixelRatio||1;
  gw=gameCanvas.clientWidth; gh=gameCanvas.clientHeight;
  gameCanvas.width=Math.floor(gw*DPR); gameCanvas.height=Math.floor(gh*DPR);
  gCtx=gameCanvas.getContext("2d"); gCtx.setTransform(DPR,0,0,DPR,0,0);
  const w=Math.max(90,gw*0.2);
  catcher = { x: gw/2, y: gh-26, w, h: 16 };
}
window.addEventListener("resize", ()=>{ if(gameModal.style.display==="flex") resizeGame(); });

/* controls */
let keys={};
window.addEventListener("keydown", e=>{ if(gameModal.style.display!=="flex") return; if(e.key==="ArrowLeft"||e.key==="ArrowRight"){ keys[e.key]=true; e.preventDefault(); }});
window.addEventListener("keyup",   e=>{ if(e.key==="ArrowLeft"||e.key==="ArrowRight"){ keys[e.key]=false; }});
function moveTo(clientX){ const rect=gameCanvas.getBoundingClientRect(); const x=Math.max(0,Math.min(gw,clientX-rect.left)); catcher.x=x; }
gameCanvas.addEventListener("mousemove", e=> moveTo(e.clientX));
gameCanvas.addEventListener("touchstart", e=>{ e.preventDefault(); if(e.touches[0]) moveTo(e.touches[0].clientX);},{passive:false});
gameCanvas.addEventListener("touchmove",  e=>{ e.preventDefault(); if(e.touches[0]) moveTo(e.touches[0].clientX);},{passive:false});

/* item spawning */
const COLORS = ["#22d3ee","#60a5fa","#f472b6","#34d399","#fbbf24","#f87171","#a78bfa"];
function isDoubleMode(){ return performance.now() < doubleUntil; }

function spawnDrop(){
  // Spawn mix changes if Double Mode is active (more bombs!)
  // Base: 10% x2, 20% bomb, 65% good, 5% rare
  // Double Mode: 15% x2, 35% bomb, 45% good, 5% rare
  const dm = isDoubleMode();
  const r = Math.random()*100;
  let kind, value, color;

  if ((!dm && r < 10) || (dm && r < 15)) {
    kind="double"; value=2; color="#a855f7";           // purple √ó2 block (tiny & fast)
  } else if ((!dm && r < 30) || (dm && r < 50)) {
    kind="bomb"; value=-3; color="#111";               // more bombs in double mode
  } else if ((!dm && r < 95) || (dm && r < 95)) {
    kind="good"; value=1; color=COLORS[Math|Math.random()*COLORS.length];
  } else {
    kind="rare"; value=3; color="#ffd166";
  }

  // sizes & speeds
  let size, vy;
  if (kind === "double") { size = 10 + Math.random()*5; vy = 3.6 + Math.random()*2.2; }
  else if (kind === "bomb") { size = 16 + Math.random()*10; vy = 2.4 + Math.random()*2.6; }
  else if (kind === "rare") { size = 16 + Math.random()*10; vy = 2.4 + Math.random()*2.4; }
  else { size = 14 + Math.random()*8; vy = 2.2 + Math.random()*2.2; }

  // faster overall when in double mode
  if (dm) vy *= 1.15;

  drops.push({ kind, value, color, x: Math.random()*gw, y: -30, vy, size });
}

function drawItem(ctx, d){
  ctx.save(); ctx.translate(d.x, d.y);
  if (d.kind === "bomb") {
    ctx.fillStyle = "#111";
    ctx.beginPath(); ctx.arc(0, 0, d.size*0.9, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#fffb"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(d.size*0.4, -d.size*0.9);
    ctx.bezierCurveTo(d.size*0.6, -d.size*1.4, d.size*0.9, -d.size*1.3, d.size*1.1, -d.size*1.0);
    ctx.stroke();
    ctx.fillStyle = "#ff4d4d";
    ctx.beginPath(); ctx.arc(d.size*1.15, -d.size*1.05, 3.2, 0, Math.PI*2); ctx.fill();
  } else if (d.kind === "rare") {
    ctx.fillStyle = d.color;
    const R = d.size, r = R*0.45;
    ctx.beginPath();
    for(let i=0;i<10;i++){ const a=i*Math.PI/5, rad=i%2===0?R:r; ctx.lineTo(Math.cos(a)*rad, Math.sin(a)*rad); }
    ctx.closePath(); ctx.shadowColor="#0006"; ctx.shadowBlur=10; ctx.fill();
  } else if (d.kind === "double") {
    // tiny purple block with ‚Äú√ó2‚Äù
    ctx.fillStyle = d.color;
    const s = d.size, rr = s*0.35;
    roundRect(ctx, -s, -s, s*2, s*2, rr); ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = `${Math.max(10, Math.round(s*1.3))}px system-ui`;
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText("√ó2", 0, 0);
  } else {
    // good gem: rounded square with M
    ctx.fillStyle = d.color;
    const s = d.size, rr = s*0.35;
    roundRect(ctx, -s, -s, s*2, s*2, rr); ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = `${Math.round(s*1.5)}px system-ui`;
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText("M", 0, 0);
  }
  ctx.restore();
}
function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y); ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
}

function drawCatcher(ctx){
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.38)";
  ctx.fillRect(catcher.x-catcher.w/2, catcher.y-catcher.h/2, catcher.w, catcher.h);
  ctx.restore();
}

function startGame(){ 
  drops=[]; score=0; scoreEl.textContent=score; tLeft=30; timeEl.textContent=tLeft; 
  running=true; lastSpawn=performance.now(); doubleUntil=0; doubleBadge.classList.remove("show");
  loop(performance.now()); countdownTick(); 
}
function stopGame(){ running=false; cancelAnimationFrame(rafId); }
startGameBtn.onclick=startGame;

function loop(now){
  if(!running) return;
  rafId=requestAnimationFrame(loop);

  // spawn pacing (faster in double mode)
  const dm = isDoubleMode();
  const interval = dm ? 200 : 260;
  if(now-lastSpawn > interval + Math.random()*220){ spawnDrop(); lastSpawn=now; }

  // controls
  const speed=7 + (dm ? 0.5 : 0);
  if(keys["ArrowLeft"]) catcher.x-=speed; 
  if(keys["ArrowRight"]) catcher.x+=speed;
  catcher.x=Math.max(catcher.w/2,Math.min(gw-catcher.w/2,catcher.x));

  gCtx.clearRect(0,0,gw,gh);

  // bomb hit flash
  if (flashUntil > performance.now()){
    gCtx.fillStyle = "rgba(255,0,0,0.15)";
    gCtx.fillRect(0,0,gw,gh);
  }

  drawCatcher(gCtx);

  for(let i=drops.length-1;i>=0;i--){
    const d=drops[i]; d.y+=d.vy; drawItem(gCtx,d);

    const withinX=Math.abs(d.x-catcher.x)<(catcher.w/2);
    const withinY=Math.abs(d.y-catcher.y)<(catcher.h+Math.max(10,d.size*0.6));
    if(withinX&&withinY){
      drops.splice(i,1);

      if (d.kind === "double") {
        // grant +2 immediately, and activate Double Mode (7s)
        score += 2;
        doubleUntil = performance.now() + 7000;
        doubleBadge.classList.add("show");
        try{ navigator.vibrate && navigator.vibrate([50,40,80]); }catch(e){}
      } else {
        const mult = isDoubleMode() ? 2 : 1;
        score += d.value * mult;
        if (d.value < 0) {
          flashUntil = performance.now()+200;
          try{ navigator.vibrate && navigator.vibrate(120); }catch(e){}
        }
      }

      if(score<0) score=0;
      scoreEl.textContent=score;
      continue;
    }
    if(d.y>gh+40){ drops.splice(i,1); }
  }

  // hide badge if double mode ended
  if (!isDoubleMode()) doubleBadge.classList.remove("show");
}

function countdownTick(){
  if(!running) return;
  setTimeout(()=>{
    tLeft -= 1; timeEl.textContent = tLeft;
    if(tLeft<=0){
      running=false;
      if(score>best){ best=score; localStorage.setItem("shapeCatchBest",best); }
      bestEl.textContent=best;

      if(score>0 && window.addScore){
        const current = window.getName ? window.getName() : "";
        let name = current || prompt("Great round! Enter your name for the leaderboard:", "") || "";
        name=(name.trim()||"Anonymous").slice(0,20);
        if(window.setName) window.setName(name);
        window.addScore(name, score); // will save only if it beats previous best
      }
      confettiBurst(800, 120);
    } else {
      countdownTick();
    }
  },1000);
}
</script>
</body>
</html>
